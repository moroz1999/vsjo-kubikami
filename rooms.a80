    module  rooms
room_number_x       db  2
room_number_y       db  0
room_amount_x       equ 6
room_amount_y       equ 4
room_w              equ 32
room_h              equ 24
room_size           equ room_w*room_h
room_bg_color1      equ 0
room_bg_color2      equ %01000001
items_in_room_max   equ 5
room_item_size      equ 3
rooms_end_marker    equ 255
init_current_room
                    call    logic.change_logic_pointer
                    call    gather_items

                    call    get_room_address
                    ld  de,screen_utils.attrs
                    ld  bc,room_size
                    ldir
                    ret
get_room_address
                ; output:
                ; hl - current room address 
                    ld  a,(room_number_y)
                    or  a
                    jr  z,get_room_address_skip_add

                    ld  b,a
                    xor a
get_room_address_y
                    add room_amount_x
                    djnz    get_room_address_y
get_room_address_skip_add
                    ld  b,a
                    ld  a,(room_number_x)
                    add b
                    add a
                    ; a now contains shift to room pointer

                    ld  l,a
                    ld  h,0
                    ld  de,room_pointers
                    add hl,de
                    ex  hl,de
                    ld  a,(de)
                    ld  l,a
                    inc de
                    ld  a,(de)
                    ld  h,a
                    ret


get_room_pixel_address
                ; input:
                ; de - coordinates
                ; output:
                ; hl - address in memory
                    call    screen_utils.get_texture_address
                    push    hl
                    call    get_room_address
                    ex  hl,de
                    pop hl
                    add hl,de
                    ret
get_room_color
                ; input:
                ; de - coordinates
                ; output:
                ; a - color of pixel
                    call    get_room_pixel_address
                    ld  a,(hl)
                    ret
set_left_room
                    ld  a,(room_number_x)
                    dec a
                    ld  (room_number_x),a
                    call    init_current_room
                    ret
set_right_room
                    ld  a,(room_number_x)
                    inc a
                    ld  (room_number_x),a
                    call    init_current_room
                    ret
set_bottom_room
                    ld  a,(room_number_y)
                    inc a
                    ld  (room_number_y),a
                    call    init_current_room
                    ret
set_top_room
                    ld  a,(room_number_y)
                    dec a
                    ld  (room_number_y),a
                    call    init_current_room
                    ret
room_pointers
                    dw  0
                    dw  room_1_0
                    dw  room_2_0
                    dw  room_3_0
                    dw  0
                    dw  0

                    dw  room_0_1
                    dw  room_1_1
                    dw  room_2_1
                    dw  room_3_1
                    dw  room_4_1
                    dw  room_5_1

                    dw  room_0_2
                    dw  0
                    dw  room_2_2
                    dw  0
                    dw  0
                    dw  0

                    dw  0
                    dw  room_1_3
                    dw  room_2_3
                    dw  room_3_3
                    dw  0
                    dw  0
gather_items
                    ld  a,(room_number_x)
                    ld  b,a
                    ld  a,(room_number_y)
                    ld  c,a

                    ld  hl,items.all_items
                    ld  de,room_items_buffer
gather_items_next
                    ld  a,(hl)
                    inc hl
                    cp  items.items_end_marker
                    jr  z,gather_items_end

                    ex  af,af'


                    ld  a,(hl)
                    inc hl
                    cp  b
                    jr  nz,gather_items_skip3

                    ld  a,(hl)
                    inc hl
                    cp  c
                    jr  nz,gather_items_skip2

                    ex  af,af'
                    ; put type
                    ld  (de),a
                    inc de

                    ld  a,(hl)
                    inc hl
                    ; put x position
                    ld  (de),a
                    inc de

                    ld  a,(hl)
                    inc hl
                    ; put y position
                    ld  (de),a
                    inc de

                    jr  gather_items_next
gather_items_skip3
    dup items.item_size-2
                    inc hl
    edup
                    jr  gather_items_next
gather_items_skip2
    dup items.item_size-3
                    inc hl
    edup
                    jr  gather_items_next
gather_items_end
                    ld  a,rooms_end_marker
                    ld  (de),a
                    ret
find_item_by_coord
                    ; input
                    ; de - x,y coordinates

                    ; output
                    ; a - type id or 255

                    ld  hl,room_items_buffer  ; Set HL to the start of the items buffer

check_next_item
                    ld  a,(hl)               ; Load item type
                    cp  255                   ; Check for end of the list (255 terminator)
                    jr  z,not_found           ; If found, item is not present

                    ex  af,af'               ; Save the item type in alternate AF

                    inc hl                   ; Move to X coordinate
                    ld  a,(hl)               ; Compare X coordinate with input
                    cp  d
                    jr  nz,next_item1          ; If X doesn't match, go to next item

                    inc hl                   ; Move to Y coordinate
                    ld  a,(hl)               ; Compare Y coordinate with input
                    cp  e
                    jr  nz,next_item2          ; If Y doesn't match, go to next item

                    ex  af,af'               ; Restore item type from alternate AF
                    ret                       ; Return item type if found

next_item1
                    inc hl                   ; Move to the next item (3 bytes per item)
                    inc hl
                    jr  check_next_item        ; Repeat the search

next_item2
                    inc hl                   ; Move to the next item (3 bytes per item)
                    jr  check_next_item        ; Repeat the search
not_found
                    ld  a,255                ; Return 255 if no item found
                    ret
room_items_buffer
                    ; item structure
                    ;
                    ; type id
                    ; x
                    ; y

                    ds  room_item_size*items_in_room_max+1
    endmodule