						module	rooms
room_number_x				db	2
room_number_y				db	0

room_amount_x				equ	6
room_amount_y				equ	4
room_w						equ	32
room_h						equ	22
room_size					equ	room_w*room_h
room_bg_color				equ	0
room_bg_color_gray			equ	%00000111
room_bg_color_sky			equ	%01000001
room_bg_color_wat			equ	%00000001
items_in_room_max			equ	5

room_item_ptr_size			equ	2
room_items_ptr_lim			equ	items_in_room_max

room_items_ptr_buf
							ds	room_items_ptr_lim*2+1
room_items_ptr_end

room_elevators_lim			equ	6
room_teleports_lim			equ	3
room_waterdrops_lim			equ	33
waterdrops_marker			equ	0
rooms_end_marker			equ	255
elev_end_marker				equ	255
item_not_found				equ	255
current_room_address		dw	2
init_current_room
							call	logic.change_logic_pointer
							call	gather_room_items
							call	gather_elevators
							call	gather_teleports
							call	gather_waterdrops

							call	calculate_room_top_y
							call	calculate_room_bottom_y

							call	get_current_room_address

							ld	(current_room_address),hl
							ld	de,screen_utils.attrs
							ld	bc,room_size
							ldir

							// update state instantly
							call	game_process.calculate_state

							ret
get_current_room_address
                ; returns start adress for current room data                
                ; output
                ; hl - address in memory
							ld	a,(room_number_x)
							ld	b,a
							ld	a,(room_number_y)
							ld	c,a
							call	get_room_address
							ret
get_room_address
                ; return start address of room data by its x/y number
                ; input
                ; b - room number x
                ; c - room number y
                ; output
                ; hl - current room address 
							push	bc
							pop	de
							ld	a,e
							or	a
							jr	z,get_room_address_skip_add
							ld	b,a
							xor	a
get_room_address_y
							add	room_amount_x
							djnz	get_room_address_y
get_room_address_skip_add
							ld	c,a
							ld	a,d
							add	c
							add	a
                    ; a now contains shift to room pointer

							ld	l,a
							ld	h,0
							ld	de,room_pointers
							add	hl,de
							ex	hl,de
							ld	a,(de)
							ld	l,a
							inc	de
							ld	a,(de)
							ld	h,a
							ret
get_current_room_pixel_address
                ; input
                ; de - coordinates
                ; output
                ; hl - address in memory
							ld	a,(room_number_x)
							ld	b,a
							ld	a,(room_number_y)
							ld	c,a
							call	get_room_pixel_address
							ret
get_room_pixel_address
                ; input:
                ; de - coordinates
                ; b - room x number
                ; c - room y number
                ; output:
                ; hl - room's pixel address in memory
							push	bc
							call	screen_utils.get_texture_address
							pop	bc
							push	hl
							call	get_room_address
							ex	hl,de
							pop	hl
							add	hl,de
							ret
get_room_color
                ; input:
                ; de - coordinates
                ; output:
                ; a - color of pixel
							call	get_current_room_pixel_address
							ld	a,(hl)
							ret
set_left_room
							ld	a,(room_number_x)
							dec	a
							ld	(room_number_x),a
							call	init_current_room
							ret
set_right_room
							ld	a,(room_number_x)
							inc	a
							ld	(room_number_x),a
							call	init_current_room
							ret
set_bottom_room
							ld	a,(room_number_y)
							inc	a
							ld	(room_number_y),a
							call	init_current_room
							ret
set_top_room
							ld	a,(room_number_y)
							dec	a
							ld	(room_number_y),a
							call	init_current_room
							ret
room_pointers
							dw	room_0_0
							dw	room_1_0
							dw	room_2_0
							dw	room_3_0
							dw	room_4_0
							dw	room_5_0

							dw	room_0_1
							dw	room_1_1
							dw	room_2_1
							dw	room_3_1
							dw	room_4_1
							dw	room_5_1

							dw	room_0_2
							dw	room_1_2
							dw	room_2_2
							dw	room_3_2
							dw	room_4_2
							dw	room_5_2

							dw	room_0_3
							dw	room_1_3
							dw	room_2_3
							dw	room_3_3
							dw	room_4_3
							dw	room_5_3

gather_waterdrops
							ld	b,waterdrops.amount
                // return if there is no waterdrops in game
							ld	a,b
							or	a
							ret	z

							ld	a,(rooms.room_number_x)
							ld	d,a

							ld	a,(rooms.room_number_y)
							ld	e,a


							ld	iy,room_waterdrops_buf
							ld	hl,waterdrops.waterdrops_table

gather_wd_next
							ld	a,(hl)
							ld	ixl,a
							inc	hl
							ld	a,(hl)
							ld	ixh,a
							inc	hl
							push	hl

                ; ix now has pointer to drop's table
							ld	a,(ix)
							cp	d
							jr	nz,gather_wd_skip
							ld	a,(ix+1)
							cp	e
							jr	nz,gather_wd_skip
							ld	a,ixl
							ld	(iy),a
							inc	iy

							ld	a,ixh
							ld	(iy),a
							inc	iy

gather_wd_skip
							pop	hl
							djnz	gather_wd_next
							ld	a,waterdrops_marker
							ld	(iy),a
							ld	(iy+1),a
							ret
gather_teleports
							ld	b,teleports.amount
                // return if there is no teleports in game
							ld	a,b
							or	a
							ret	z

							ld	a,(rooms.room_number_x)
							ld	d,a

							ld	a,(rooms.room_number_y)
							ld	e,a


							ld	iy,room_teleports_buf
							ld	hl,teleports.teleports_table

gather_tele_next
							ld	a,(hl)
							ld	ixl,a
							inc	hl
							ld	a,(hl)
							ld	ixh,a
							inc	hl
							push	hl

							ld	a,(ix)
							cp	d
							jr	nz,gather_tele_skip
							ld	a,(ix+1)
							cp	e
							jr	nz,gather_tele_skip
							ld	a,ixl
							ld	(iy),a
							inc	iy

							ld	a,ixh
							ld	(iy),a
							inc	iy

gather_tele_skip
							pop	hl
							djnz	gather_tele_next
							ld	a,rooms_end_marker

							ld	(iy),a
							ret
gather_elevators
							ld	b,elevators.amount
                // return if there is no elevators in game
							ld	a,b
							or	a
							ret	z

							ld	iy,room_elevators_buf

							ld	a,(rooms.room_number_x)
							ld	d,a

							ld	a,(rooms.room_number_y)
							ld	e,a
gather_elev_room
							ld	hl,elevators.elevators_table
							push	bc
gather_elev_next
							ld	a,(hl)
							ld	ixl,a
							inc	hl
							ld	a,(hl)
							ld	ixh,a
							inc	hl
							push	hl

							ld	a,(ix+elevators.elevator.room_x)
							cp	d
							jr	nz,gather_elev_skip
							ld	a,(ix+elevators.elevator.room_y)
							cp	e
							jr	nz,gather_elev_skip
							ld	a,ixl
							ld	(iy),a
							inc	iy

							ld	a,ixh
							ld	(iy),a
							inc	iy

gather_elev_skip
							pop	hl
							djnz	gather_elev_next
                ; restore amount of rooms in game to b                    
							pop	bc

                ; check if there are rooms below                
							inc	e
							ld	a,e
							cp	room_amount_y
							jr	nz,gather_elev_room

                ; terminate elevators buffer
							ld	a,elev_end_marker
							ld	(iy),a
							ret
						display "gather_room_items,",gather_room_items
gather_room_items
                        ; Build room_items_ptr_buf with pointers to items.item
							ld	a,(rooms.room_number_x)
							ld	d,a
							ld	a,(rooms.room_number_y)
							ld	e,a

							ld	iy,room_items_ptr_buf
							ld	hl,items.all_items
							ld	bc,items.item_size

.gr_next
							ld	a,(hl)
							cp	items.items_end_marker
							jr	z,.gr_end

                        ; IX := current item
							push	hl
							pop	ix

							ld	a,(ix+items.item.room_x)
							cp	d
							jr	nz,.gr_skip
							ld	a,(ix+items.item.room_y)
							cp	e
							jr	nz,.gr_skip

                        ; append pointer (IX) into buffer
							push	ix
							pop	de
							ld	(iy),e
							inc	iy
							ld	(iy),d
							inc	iy

.gr_skip					add	hl,bc
							jr	.gr_next

.gr_end						ld	a,rooms.rooms_end_marker
							ld	(iy),a
							ret
; find_item_ptr_by_coord
; input : DE = (x,y)
; output: Carry=1 if found, IX -> items.item,  A = type_id
;         Carry=0 if not found, A untouched
find_item_ptr_by_coord
							ld	hl,room_items_ptr_buf
.fipc_next
							ld	a,(hl)
							cp	rooms_end_marker
							jr	z,.fipc_not_found

                            ; load pointer -> IX
							ld	ixl,a
							inc	hl
							ld	a,(hl)
							ld	ixh,a
							inc	hl

							ld	a,(ix+items.item.room_pos_x)
							cp	d
							jr	nz,.fipc_next
							ld	a,(ix+items.item.room_pos_y)
							cp	e
							jr	nz,.fipc_next

                            ; found
							ld	a,(ix+items.item.type_id)
							scf
							ret
.fipc_not_found
							or	a              ; clear carry
							ret

; Backward-compatible wrapper: returns type id or 255
find_item_by_coord
							call	find_item_ptr_by_coord
							jr	c,.fibc_found
							ld	a,item_not_found
							ret
.fibc_found
                            ; A already has type_id
							ret
; spawn_item
; input : A = type_id, B = x, C = y
; spawn_item
; input : A = type_id, B = x, C = y
spawn_item
                        ; find end of pointer buffer							
							ld	hl,rooms.room_items_ptr_buf
.si_seek_end				ld	a,(hl)
							cp	rooms.rooms_end_marker
							jr	z,.si_end_found
							inc	hl
							inc	hl
							jr	.si_seek_end
.si_end_found				push	hl                      ; save write position

                        ; IX := item base
							call	items.get_item_address  ; HL = base
							push	hl
							pop	ix

                        ; set room and position fields
							ld	a,(rooms.room_number_x)
							ld	(ix+items.item.room_x),a
							ld	a,(rooms.room_number_y)
							ld	(ix+items.item.room_y),a
							ld	a,b
							ld	(ix+items.item.room_pos_x),a
							ld	a,c
							ld	(ix+items.item.room_pos_y),a

                        ; write pointer to buffer and terminate
							pop	hl                      ; HL = write pos
							push	ix
							pop	de
							ld	(hl),e
							inc	hl
							ld	(hl),d
							inc	hl
							ld	a,rooms.rooms_end_marker
							ld	(hl),a
							ret

remove_item
						; input:
						; A = type_id							
							ld	hl,rooms.room_items_ptr_buf
							ld	b,a                        ; B = type_id
remove_item_search
							ld	a,(hl)
							cp	rooms.rooms_end_marker
							ret	z
                        
							ld	e,(hl)
							inc	hl
							ld	d,(hl)
							inc	hl
							push	de
							pop	ix

							ld	a,(ix+items.item.type_id)
							cp	b
							jr	nz,remove_item_search

                        ; HL currently points AFTER the entry -> back 2 bytes
							dec hl
							dec hl
							
							push	hl
							ld	de,2
							add	hl,de                      ; HL = src (next entry)
							push	hl
							ex	hl,de                      ; DE = src, HL = dst

							ld	hl,rooms.room_items_ptr_end
							xor	a
							sbc	hl,de                      ; HL = bytes to move
							push	hl
							pop	bc
							pop	hl                          ; HL = src
							pop	de                          ; DE = dst
							ldir

							ld	a,b
							call	items.remove_item       ; mark item "not in room"
							ret

						; remove_item_by_ptr
						; input : IX -> items.item
remove_item_by_ptr
							ld	hl,rooms.room_items_ptr_buf
.rip_next
							ld	a,(hl)
							cp	rooms.rooms_end_marker
							jr	z,.rip_done

							ld	e,(hl)
							inc	hl
							ld	d,(hl)
							inc	hl                         ; HL -> next entry

                        ; compare with IX
							ld	a,ixl
							cp	e
							jr	nz,.rip_next
							ld	a,ixh
							cp	d
							jr	nz,.rip_next

                        ; delete entry (HL is after it)
							or	a
							ld	de,2
							sbc	hl,de
							push	hl
							ld	de,2
							add	hl,de
							push	hl
							ex	hl,de
							ld	hl,rooms.room_items_ptr_end
							xor	a
							sbc	hl,de
							push	hl
							pop	bc
							pop	hl
							pop	de
							ldir

							ld	a,(ix+items.item.type_id)
							call	items.remove_item
.rip_done					ret

room_items_buffer

							ds	items.item*items_in_room_max+1
room_items_end
room_elevators_buf
							ds	room_elevators_lim*2+1
room_elevators_end
room_teleports_buf
							ds	room_teleports_lim*2+1
room_teleports_end

room_waterdrops_buf
							ds	room_waterdrops_lim*2+1
room_waterdrops_end

calculate_room_top_y
                ; calculate top y coordinate of current room
                ;
                ; $current_room_top_coord_y = $current_room_y * $each_room_height;
							ld	a,(room_number_y)
							ld	h,a
							ld	e,room_h

							call	math.mul8b
							ld	a,l
							ld	(room_top_y),a
							ret
calculate_room_bottom_y
                ; calculate bottom y coordinate of current room
                ;
                ; $current_room_bottom_coord_y = $current_room_top_coord_y + $each_room_height - 1;
							ld	a,(room_top_y)
							add	room_h-1
							ld	(room_bottom_y),a
							ret
room_top_y					db	0
room_bottom_y				db	0

						endmodule