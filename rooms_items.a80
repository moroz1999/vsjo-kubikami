                            display	'draw_room_items,',draw_room_items
draw_room_items

                            ld	hl,room_items_buffer
                            ld	a,(room_items_count)
                            ld	b,a

draw_room_items_next
                            push	bc

                        ; DE = pointer
                            ld	e,(hl)
                            inc	hl
                            ld	d,(hl)
                            inc	hl

                            push	hl

                        ; IX := DE
                            push	de
                            pop	ix

                        ; D,E = item coordinates
                            ld	d,(ix+items.item.room_pos_x)
                            ld	e,(ix+items.item.room_pos_y)

                        ; HL = color1 inside item
                            push	ix
                            pop	hl
                            ld	bc,items.item.color1
                            add	hl,bc

                            call	draw.draw_gigapoint
                            pop	hl
                            pop	bc
                            djnz	draw_room_items_next
                            ret

gather_room_items                            
                        ; Build room_items_buffer with pointers to items.item
                            xor	a
                            ld	(room_items_count),a

                            ld	a,(room_number_x)
                            ld	d,a
                            ld	a,(room_number_y)
                            ld	e,a

                            ld	hl,room_items_buffer
                            ld	ix,items.all_items
                            ld	bc,items.item_size
gather_room_next
                            ld	a,(ix)
                            cp	items.items_end_marker
                            ret	z

                            ld	a,(ix+items.item.room_x)
                            cp	d
                            jr	nz,gather_room_skip
                            ld	a,(ix+items.item.room_y)
                            cp	e
                            jr	nz,gather_room_skip

                        ; append pointer (IX) into buffer
                            push	ix
                            pop	de
                            ld	(hl),e
                            inc	hl
                            ld	(hl),d
                            inc	hl

						; increase items counter in room
                            ld	a,(room_items_count)
                            inc	a
                            ld	(room_items_count),a

gather_room_skip
						; pointer to next item start
                            add	ix,bc
                            jr	gather_room_next

gather_room_end             ld	a,rooms_end_marker
                            ld	(iy),a
                            ret
find_item_ptr_by_coord
                            or	a
                            ret
						; input : DE = (x,y)
						; output: Carry=1 if found, IX -> items.item,  A = type_id
						;         Carry=0 if not found, A untouched
                            ld	hl,room_items_buffer
.fipc_next
                            ld	a,(hl)
                            cp	rooms_end_marker
                            jr	z,.fipc_not_found

                            ; load pointer -> IX
                            ld	ixl,a
                            inc	hl
                            ld	a,(hl)
                            ld	ixh,a
                            inc	hl

                            ld	a,(ix+items.item.room_pos_x)
                            cp	d
                            jr	nz,.fipc_next
                            ld	a,(ix+items.item.room_pos_y)
                            cp	e
                            jr	nz,.fipc_next

                            ; found
                            ld	a,(ix+items.item.type_id)
                            scf
                            ret
.fipc_not_found
                            or	a              ; clear carry
                            ret

; Backward-compatible wrapper: returns type id or 255
find_item_by_coord
                            call	find_item_ptr_by_coord
                            jr	c,.fibc_found
                            ld	a,item_not_found
                            ret
.fibc_found
                            ; A already has type_id
                            ret

spawn_item
						; input : A = type_id, B = x, C = y
                            ret
                        ; find end of pointer buffer
                            ld	hl,room_items_buffer
.si_seek_end                ld	a,(hl)
                            cp	rooms_end_marker
                            jr	z,.si_end_found
                            inc	hl
                            inc	hl
                            jr	.si_seek_end
.si_end_found               push	hl                      ; save write position

                        ; IX := item base
                            call	items.get_item_address  ; HL = base
                            push	hl
                            pop	ix

                        ; set room and position fields
                            ld	a,(room_number_x)
                            ld	(ix+items.item.room_x),a
                            ld	a,(room_number_y)
                            ld	(ix+items.item.room_y),a
                            ld	a,b
                            ld	(ix+items.item.room_pos_x),a
                            ld	a,c
                            ld	(ix+items.item.room_pos_y),a

                        ; write pointer to buffer and terminate
                            pop	hl                      ; HL = write pos
                            push	ix
                            pop	de
                            ld	(hl),e
                            inc	hl
                            ld	(hl),d
                            inc	hl
                            ld	a,rooms_end_marker
                            ld	(hl),a
                            ret

remove_item
                            ret
						; input:
						; A = type_id							
                            ld	hl,room_items_buffer
                            ld	b,a                        ; B = type_id
remove_item_search
                            ld	a,(hl)
                            cp	rooms_end_marker
                            ret	z

                            ld	e,(hl)
                            inc	hl
                            ld	d,(hl)
                            inc	hl
                            push	de
                            pop	ix

                            ld	a,(ix+items.item.type_id)
                            cp	b
                            jr	nz,remove_item_search

                        ; HL currently points AFTER the entry -> back 2 bytes
                            dec	hl
                            dec	hl

                            push	hl
                            ld	de,2
                            add	hl,de                      ; HL = src (next entry)
                            push	hl
                            ex	hl,de                      ; DE = src, HL = dst

                            ld	hl,room_items_buf_end
                            xor	a
                            sbc	hl,de                      ; HL = bytes to move
                            push	hl
                            pop	bc
                            pop	hl                          ; HL = src
                            pop	de                          ; DE = dst
                            ldir

                            ld	a,b
                            call	items.remove_item       ; mark item "not in room"
                            ret

						; input : IX -> items.item
remove_item_by_ptr
                            ld	hl,room_items_buffer
.rip_next
                            ld	a,(hl)
                            cp	rooms_end_marker
                            jr	z,.rip_done

                            ld	e,(hl)
                            inc	hl
                            ld	d,(hl)
                            inc	hl                         ; HL -> next entry

                        ; compare with IX
                            ld	a,ixl
                            cp	e
                            jr	nz,.rip_next
                            ld	a,ixh
                            cp	d
                            jr	nz,.rip_next

                        ; delete entry (HL is after it)
                            or	a
                            ld	de,2
                            sbc	hl,de
                            push	hl
                            ld	de,2
                            add	hl,de
                            push	hl
                            ex	hl,de
                            ld	hl,room_items_buf_end
                            xor	a
                            sbc	hl,de
                            push	hl
                            pop	bc
                            pop	hl
                            pop	de
                            ldir

                            ld	a,(ix+items.item.type_id)
                            call	items.remove_item
.rip_done                   ret

items_in_room_max           equ	10
room_items_count            db	0
room_items_buffer
                            ds	items_in_room_max*2
room_items_buf_end
