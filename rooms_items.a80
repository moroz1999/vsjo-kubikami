                            display	'draw_room_items,',draw_room_items
draw_room_items

                            ld	hl,room_items_buffer
                            ld	a,(room_items_count)
                            or	a
                            ret	z
                            ld	b,a

draw_room_items_next
                            push	bc

                        ; read item pointer to IX
                            ld	a,(hl)
                            inc	hl
                            ld	ixl,a
                            ld	a,(hl)
                            inc	hl
                            ld	ixh,a

                            push	hl

                        ; D,E = item coordinates
                            ld	d,(ix+items.item.room_pos_x)
                            ld	e,(ix+items.item.room_pos_y)

                        ; HL = color1 inside item
                            push	ix
                            pop	hl
                            ld	bc,items.item.color1
                            add	hl,bc

                            call	draw.draw_gigapoint
                            pop	hl
                            pop	bc
                            djnz	draw_room_items_next
                            ret
                            display	'gather_room_items,',gather_room_items

gather_room_items
                        ; Build room_items_buffer with pointers to items.item
                            xor	a
                            ld	(room_items_count),a

                            ld	a,(room_number_x)
                            ld	d,a
                            ld	a,(room_number_y)
                            ld	e,a

                            ld	hl,room_items_buffer
                            ld	ix,items.all_items
                            ld	bc,items.item_size
gather_room_next
                            ld	a,(ix)
                            cp	items.items_end_marker
                            ret	z

                            ld	a,(ix+items.item.room_x)
                            cp	d
                            jr	nz,gather_room_skip
                            ld	a,(ix+items.item.room_y)
                            cp	e
                            jr	nz,gather_room_skip

                        ; append pointer (IX) into buffer
                            ld	a,ixl
                            ld	(hl),a
                            inc	hl
                            ld	a,ixh
                            ld	(hl),a
                            inc	hl

						; increase items counter in room
                            ld	a,(room_items_count)
                            inc	a
                            ld	(room_items_count),a

gather_room_skip
						; pointer to next item start
                            add	ix,bc
                            jr	gather_room_next

gather_room_end             ld	a,rooms_end_marker
                            ld	(iy),a
                            ret
item_not_found              equ	255

find_item_by_coord
						; input : DE = (x,y)
						; output: Carry=1 if found, IX -> items.item,  A = type_id
						;         Carry=0 if not found, A untouched
                            ld	hl,room_items_buffer
                            ld	a,(room_items_count)
                        ; are there items in room?                            
                            or	a
                            jr	z,find_item_not_found

                            ld	b,a
find_item_next
                            xor	a
                            or	b
                            jr	z,find_item_not_found
                            dec	b

                            ; load pointer -> IX
                            ld	a,(hl)
                            ld	ixl,a
                            inc	hl
                            ld	a,(hl)
                            ld	ixh,a
                            inc	hl

                            ld	a,(ix+items.item.room_pos_x)
                            cp	d
                            jr	nz,find_item_next
                            ld	a,(ix+items.item.room_pos_y)
                            cp	e
                            jr	nz,find_item_next

                            ; found
                            ld	a,(ix+items.item.type_id)
                            ret
find_item_not_found
                            ld	a,item_not_found
                            ret

spawn_item
						; input : 
                        ; A = type_id
                        ; B = x
                        ; C = y

                        ; find end of pointer buffer
                            ex	af,af'

                            ld	hl,room_items_buffer
                            ld	a,(room_items_count)
                            add	a

                            ld	e,a
                            ld	d,0
                            add	hl,de
                            ex	af,af'
                            ; hl now points to buffer end                            

                        ; save write position                            
                            push	hl
                        ; save coordinates
                            push	bc


                            call	items.get_item_address  ; HL = base
                            push	hl
                            pop	ix
                        ; ix now points to item

                        ; restore coordinates to BC                            
                            pop	bc

                        ; set room and position fields
                            ld	a,(room_number_x)
                            ld	(ix+items.item.room_x),a
                            ld	a,(room_number_y)
                            ld	(ix+items.item.room_y),a
                            ld	a,b
                            ld	(ix+items.item.room_pos_x),a
                            ld	a,c
                            ld	(ix+items.item.room_pos_y),a

                        ; put item pointer to de
                            push	ix
                            pop	de

                        ; restore write position    
                            pop	hl

                        ; write pointer to room buffer   
                            ld	(hl),e
                            inc	hl
                            ld	(hl),d
                            inc	hl

                            ld	a,(room_items_count)
                            inc	a
                            ld	(room_items_count),a
                            ret

remove_item
						; input:
						; A = type_id
                            ld	c,a                        ; C = type_id

                            ld	hl,room_items_buffer
                            ld	a,(room_items_count)
                            ld	b,a
remove_item_search
                            xor	a
                            or	b
                            ret	z
                            dec	b

                            ld	a,(hl)
                            inc	hl
                            ld	ixl,a
                            ld	a,(hl)
                            inc	hl
                            ld	ixh,a

                            ld	a,(ix+items.item.type_id)
                            cp	c
                            jr	nz,remove_item_search

                        ; HL currently points AFTER the entry -> back 2 bytes
                            dec	hl
                            dec	hl

                            push	hl
                            inc	hl
                            inc	hl
                        ; HL = src (next entry)

                            push	hl
                            ex	hl,de
                        ; DE = src, HL = dst                            

                            ld	hl,room_items_buf_end
                            xor	a
                            sbc	hl,de                      ; HL = bytes to move
                            push	hl

                            pop	bc
                            pop	hl                          ; HL = src
                            pop	de                          ; DE = dst
                            ldir

                            ld	a,c
                            call	items.remove_item       ; mark item "not in room"
                            ret

						; input : IX -> items.item
remove_item_by_ptr
                            ld	hl,room_items_buffer
.rip_next
                            ld	a,(hl)
                            cp	rooms_end_marker
                            jr	z,.rip_done

                            ld	e,(hl)
                            inc	hl
                            ld	d,(hl)
                            inc	hl                         ; HL -> next entry

                        ; compare with IX
                            ld	a,ixl
                            cp	e
                            jr	nz,.rip_next
                            ld	a,ixh
                            cp	d
                            jr	nz,.rip_next

                        ; delete entry (HL is after it)
                            or	a
                            ld	de,2
                            sbc	hl,de
                            push	hl
                            ld	de,2
                            add	hl,de
                            push	hl
                            ex	hl,de
                            ld	hl,room_items_buf_end
                            xor	a
                            sbc	hl,de
                            push	hl
                            pop	bc
                            pop	hl
                            pop	de
                            ldir

                            ld	a,(ix+items.item.type_id)
                            call	items.remove_item
.rip_done                   ret

items_in_room_max           equ	10
room_items_count            db	0
room_items_buffer
                            ds	items_in_room_max*2
room_items_buf_end
